코드 모듈화를 적용하는 **CMake 예제**를 통해 프로젝트를 나누어 관리하는 방법을 보여드릴게요. 모듈화를 사용하면 프로젝트를 여러 파일로 나누어 각 파일에서 특정 기능을 담당하게 할 수 있습니다. 이 과정에서, CMake는 모듈을 포함하고 빌드 과정을 자동화하는 역할을 합니다.

### 예제: 간단한 모듈화된 프로젝트

이번 예제에서는:

- **MathModule**: 간단한 수학 기능을 담당하는 모듈.
- **UtilityModule**: 로깅 및 유틸리티 기능을 제공하는 모듈.
- **Main 프로그램**: 모듈들을 포함하여 전체 프로그램을 실행하는 메인 프로그램.

### 1. **프로젝트 구조**

```
MyModularProject/
├── CMakeLists.txt
├── main.cpp
├── MathModule/
│   ├── CMakeLists.txt
│   ├── MathFunctions.cpp
│   └── MathFunctions.h
└── UtilityModule/
    ├── CMakeLists.txt
    ├── Logger.cpp
    └── Logger.h
```

### 2. **모듈 코드**

#### `MathModule/MathFunctions.h`

```cpp
#pragma once

class MathFunctions {
public:
    static int add(int a, int b);
    static int subtract(int a, int b);
};
```

#### `MathModule/MathFunctions.cpp`

```cpp
#include "MathFunctions.h"

int MathFunctions::add(int a, int b) {
    return a + b;
}

int MathFunctions::subtract(int a, int b) {
    return a - b;
}
```

#### `UtilityModule/Logger.h`

```cpp
#pragma once
#include <string>

class Logger {
public:
    static void log(const std::string& message);
};
```

#### `UtilityModule/Logger.cpp`

```cpp
#include "Logger.h"
#include <iostream>

void Logger::log(const std::string& message) {
    std::cout << "LOG: " << message << std::endl;
}
```

### 3. **Main 프로그램**

#### `main.cpp`

```cpp
#include "MathFunctions.h"
#include "Logger.h"

int main() {
    int result = MathFunctions::add(5, 3);
    Logger::log("The result of 5 + 3 is " + std::to_string(result));

    result = MathFunctions::subtract(9, 4);
    Logger::log("The result of 9 - 4 is " + std::to_string(result));

    return 0;
}
```

### 4. **CMake 설정**

#### 최상위 `CMakeLists.txt`

최상위 CMakeLists 파일은 각 모듈 디렉토리의 CMakeLists를 포함하고, 메인 프로그램이 두 모듈을 사용할 수 있도록 설정합니다.

```cmake
cmake_minimum_required(VERSION 3.10)
project(MyModularProject VERSION 1.0)

# C++ 표준 설정
set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD_REQUIRED True)

# 서브 디렉토리 포함
add_subdirectory(MathModule)
add_subdirectory(UtilityModule)

# 메인 프로그램을 위한 실행 파일 생성
add_executable(MainProgram main.cpp)

# 메인 프로그램이 MathModule과 UtilityModule을 사용할 수 있도록 링크
target_link_libraries(MainProgram PUBLIC MathModule UtilityModule)
```

#### `MathModule/CMakeLists.txt`

MathModule의 CMake 파일은 MathFunctions.cpp에서 라이브러리를 만듭니다.

```cmake
# MathFunctions.cpp를 기반으로 MathModule을 만듭니다
add_library(MathModule MathFunctions.cpp)
```

#### `UtilityModule/CMakeLists.txt`

UtilityModule의 CMake 파일은 Logger.cpp에서 라이브러리를 만듭니다.

```cmake
# Logger.cpp를 기반으로 UtilityModule을 만듭니다
add_library(UtilityModule Logger.cpp)
```

### 5. **빌드 및 실행 방법**

#### 1. 빌드 디렉토리 생성 및 CMake 실행

터미널에서 프로젝트 루트 디렉토리로 이동한 후:

```bash
mkdir build
cd build
cmake ..
cmake --build .
```

#### 2. 프로그램 실행

빌드가 완료되면, 생성된 실행 파일을 실행할 수 있습니다:

```bash
./MainProgram    # Linux/macOS
MainProgram.exe  # Windows
```

### 6. **결과**

프로그램을 실행하면 모듈화된 MathModule과 UtilityModule의 기능을 사용하여 결과를 출력합니다:

```
LOG: The result of 5 + 3 is 8
LOG: The result of 9 - 4 is 5
```

### 7. **모듈화의 장점**

- **코드 분리**: 각 모듈이 특정 기능을 담당하므로 코드가 더 깔끔하고 관리하기 쉬워집니다.
- **재사용성**: MathModule과 UtilityModule은 독립적이므로 다른 프로젝트에서 재사용할 수 있습니다.
- **독립적 테스트**: 모듈 단위로 테스트를 수행할 수 있어, 오류를 더 쉽게 찾을 수 있습니다.

### 정리

이 예제에서는 **모듈화된 프로젝트**를 CMake로 설정하는 방법을 보여드렸습니다. 모듈은 각 기능을 독립적으로 관리할 수 있게 하며, 코드의 유지보수성과 재사용성을 높이는 좋은 방법입니다. 라이브러리 대신 모듈로 코드를 나누는 방식이 프로젝트에 적합한 경우, 이런 구조를 사용할 수 있습니다.

더 궁금한 부분이 있으면 언제든지 질문하세요!
